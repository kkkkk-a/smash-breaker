<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ã‚¹ãƒãƒƒã‚·ãƒ¥ãƒ–ãƒ¬ã‚¤ã‚«ãƒ¼ (FINAL)</title>
    <link rel="icon" type="image/png" href="icon.png">
    <!-- Libraries -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;800&family=Orbitron:wght@700&display=swap" rel="stylesheet">

<style>
:root {
    --bg-color: #0d0d15;
    --primary: #00f2ff;
    --accent: #ff0055;
    --text: #fff;
}

body {
    margin: 0; background: var(--bg-color); color: var(--text);
    font-family: 'M PLUS Rounded 1c', sans-serif;
    height: 100vh; overflow: hidden; 
    touch-action: none;
    display: flex; justify-content: center; align-items: center;
    user-select: none; -webkit-user-select: none;
}

/* ç”»é¢ç®¡ç† */
.screen {
    position: absolute; width: 100%; height: 100%;
    display: none; flex-direction: column; align-items: center; justify-content: center;
    background: radial-gradient(circle, #1a1a2e 0%, #000 100%); z-index: 10;
}
.screen.active { display: flex; z-index: 20; }

/* HUBãƒœã‚¿ãƒ³ (æŒ‡å®šãƒ‡ã‚¶ã‚¤ãƒ³) */
.nav-return-btn {
    display: inline-block;
    padding: 8px 16px;
    border-radius: 10px;
    background: rgba(0, 210, 255, 0.15);
    color: #00d2ff;
    text-decoration: none;
    font-weight: 600;
    font-size: 0.85rem;
    border: 1px solid rgba(0, 210, 255, 0.4);
    position: absolute; top: 20px; left: 20px; z-index: 100;
}
.nav-return-btn:hover { background: rgba(0, 210, 255, 0.3); }

/* UIãƒ‘ãƒ¼ãƒ„ */
h1 { font-family: 'Orbitron', sans-serif; font-size: 2.5rem; text-shadow: 0 0 15px var(--primary); margin: 0 0 10px 0; text-align: center; }
.desc { color: #aaa; font-size: 0.8rem; margin-bottom: 20px; text-align: center; line-height: 1.5; }

.btn {
    width: 260px; padding: 16px; margin: 8px;
    background: rgba(255,255,255,0.05); border: 2px solid var(--primary); color: var(--primary);
    font-family: 'Orbitron', sans-serif; font-size: 1.1rem; cursor: pointer;
    border-radius: 50px; transition: 0.2s; text-transform: uppercase;
}
.btn:active { background: var(--primary); color: #000; transform: scale(0.95); }
.btn-accent { border-color: var(--accent); color: var(--accent); }
.btn-accent:active { background: var(--accent); color: #000; }

/* ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ç”»é¢ */
.input-box { font-size: 1.2rem; padding: 10px; width: 200px; text-align: center; background: #222; border: 1px solid #555; color: #fff; border-radius: 5px; margin: 10px; }
#qr-display { background: #fff; padding: 10px; border-radius: 5px; margin: 15px; }
#cam-wrapper { width: 250px; border: 2px solid var(--primary); display: none; margin: 10px; border-radius: 5px; overflow: hidden; }

/* ã‚²ãƒ¼ãƒ ç”»é¢ */
#game-wrapper {
    position: relative; width: 100%; height: 100%; max-width: 600px;
    background: #000; overflow: hidden; box-shadow: 0 0 50px rgba(0,0,0,0.5);
}
canvas { display: block; width: 100%; height: 100%; touch-action: none; }

/* HUD */
.hud {
    position: absolute; top: 10px; left: 0; width: 100%; padding: 0 15px;
    display: flex; justify-content: space-between; box-sizing: border-box;
    font-family: 'Orbitron'; font-size: 1rem; pointer-events: none; z-index: 5;
    text-shadow: 0 2px 2px #000;
}

/* ã‚¹ãƒãƒ›æ“ä½œãƒ‘ãƒãƒ« */
.control-panel {
    position: absolute; bottom: 30px; width: 100%;
    display: flex; justify-content: space-around; align-items: center;
    padding: 0 20px; box-sizing: border-box; z-index: 100;
    pointer-events: none;
}
.ctrl-btn {
    width: 70px; height: 70px; border-radius: 50%;
    background: rgba(255,255,255,0.15); border: 2px solid rgba(255,255,255,0.5);
    color: #fff; font-size: 1.5rem; display: flex; justify-content: center; align-items: center;
    backdrop-filter: blur(4px); pointer-events: auto; cursor: pointer; transition: 0.1s; user-select: none;
}
.ctrl-btn:active, .ctrl-btn.pressed { background: rgba(255,255,255,0.5); transform: scale(0.9); }
.btn-charge { width: 90px; height: 90px; border-color: var(--accent); color: var(--accent); font-weight: bold; font-size: 2rem; }
.btn-charge:active, .btn-charge.pressed { background: var(--accent); color: #fff; box-shadow: 0 0 20px var(--accent); }

/* ãƒ¢ãƒ¼ãƒ€ãƒ« */
.modal {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85); display: none; flex-direction: column;
    justify-content: center; align-items: center; z-index: 200;
}
.blink { animation: blink 1s infinite alternate; }
@keyframes blink { from { opacity: 0.4; } to { opacity: 1; } }
</style>
</head>
<body>

<!-- ã‚¿ã‚¤ãƒˆãƒ« -->
<div id="screen-title" class="screen active">
    <!-- HUBãƒœã‚¿ãƒ³ -->
    <a href="https://kkkkk-a.github.io/game-hub/" class="nav-return-btn" title="Game Hub">HUB</a>

    <h1>SMASH<br>BREAKER</h1>
    <div class="desc">
        [P1] çŸ¢å°ã‚­ãƒ¼ç§»å‹• + ä¸Šä¸‹å›è»¢ + å³Shiftãƒãƒ£ãƒ¼ã‚¸<br>
        [P2] WASDç§»å‹• + WSå›è»¢ + å·¦Shiftãƒãƒ£ãƒ¼ã‚¸
    </div>
    
    <button class="btn" onclick="Game.initLocal()">ã²ã¨ã‚Š / ãƒ­ãƒ¼ã‚«ãƒ«å¯¾æˆ¦</button>
    <button class="btn btn-accent" onclick="Net.openMenu()">é€šä¿¡å¯¾æˆ¦ (QR/ID)</button>
</div>

<!-- ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ -->
<div id="screen-net" class="screen">
    <h2>ONLINE BATTLE</h2>
    <div id="net-select" style="display:flex; flex-direction:column; align-items:center;">
        <button class="btn" onclick="Net.initHost()">éƒ¨å±‹ã‚’ã¤ãã‚‹ (HOST)</button>
        <button class="btn btn-accent" onclick="Net.showGuest()">éƒ¨å±‹ã«å…¥ã‚‹ (GUEST)</button>
        <button class="btn" style="border-color:#555; color:#aaa;" onclick="location.reload()">ã‚‚ã©ã‚‹</button>
    </div>
    
    <div id="net-host" style="display:none; flex-direction:column; align-items:center;">
        <div id="qr-display"></div>
        <div>ID: <span id="host-id-text" style="color:var(--primary); font-weight:bold;">---</span></div>
        <div class="blink" style="color:var(--accent); margin-top:10px;">æ¥ç¶šå¾…ã¡...</div>
        <button class="btn" onclick="location.reload()" style="margin-top:20px;">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
    </div>

    <div id="net-guest" style="display:none; flex-direction:column; align-items:center;">
        <div id="cam-wrapper"></div>
        <button class="btn" onclick="Net.startCam()">ğŸ“· QRã‚¹ã‚­ãƒ£ãƒ³</button>
        <input type="text" id="input-id" class="input-box" placeholder="IDã‚’å…¥åŠ›">
        <button class="btn btn-accent" onclick="Net.joinInput()">æ¥ç¶šã™ã‚‹</button>
        <button class="btn" onclick="location.reload()" style="margin-top:10px;">ã‚‚ã©ã‚‹</button>
    </div>
</div>

<!-- ã‚²ãƒ¼ãƒ ç”»é¢ -->
<div id="screen-game" class="screen" style="background:#000; padding:0;">
    <div id="game-wrapper">
        <canvas id="game-canvas"></canvas>
        
        <div class="hud">
            <div id="hud-p2">P2: 0</div>
            <div id="hud-p1">P1: 0</div>
        </div>

        <!-- ã‚¹ãƒãƒ›ç”¨æ“ä½œãƒ‘ãƒãƒ« (P1æ“ä½œ) -->
        <div class="control-panel">
            <div id="btn-left" class="ctrl-btn">â†º</div>
            <div id="btn-charge" class="ctrl-btn btn-charge">âš¡</div>
            <div id="btn-right" class="ctrl-btn">â†»</div>
        </div>

        <!-- çµæœ -->
        <div id="modal-result" class="modal">
            <h2 id="res-msg">WIN!</h2>
            <button class="btn" onclick="location.reload()">ã‚¿ã‚¤ãƒˆãƒ«ã¸</button>
        </div>
        
        <!-- å¾…æ©Ÿ -->
        <div id="modal-wait" class="modal">
            <h2 class="blink">WAITING...</h2>
        </div>
    </div>
</div>

<script>
/**
 * SMASH BREAKER - COMPLETE EDITION
 * - Local 2P (Keyboard)
 * - Online (PeerJS/QR)
 * - Mobile Touch Controls (Pointer Events)
 * - Zenmai Physics (Wind-up Charge)
 */

const AudioSys = {
    ctx: null,
    init() { 
        if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)();
        if(this.ctx.state === 'suspended') this.ctx.resume();
    },
    play(type) {
        if(!this.ctx) return;
        const t = this.ctx.currentTime;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.connect(g); g.connect(this.ctx.destination);
        
        if(type==='hit') {
            o.type='square'; o.frequency.setValueAtTime(400, t);
            g.gain.exponentialRampToValueAtTime(0.01, t+0.1);
        } else if(type==='wind') {
            o.type='sawtooth'; o.frequency.setValueAtTime(100, t);
            g.gain.setValueAtTime(0.1, t); g.gain.linearRampToValueAtTime(0, t+0.05);
        } else if(type==='smash') {
            o.type='sawtooth'; o.frequency.setValueAtTime(150, t); o.frequency.linearRampToValueAtTime(600, t+0.2);
            g.gain.setValueAtTime(0.5, t); g.gain.exponentialRampToValueAtTime(0.01, t+0.3);
        } else if(type==='break') {
            o.type='square'; o.frequency.setValueAtTime(120, t);
            g.gain.exponentialRampToValueAtTime(0.01, t+0.2);
        } else if(type==='win') {
            o.type='triangle'; o.frequency.setValueAtTime(523, t); g.gain.linearRampToValueAtTime(0, t+1.0);
        }
        o.start(); o.stop(t+0.5);
    }
};

// --- å…¥åŠ›ç®¡ç† ---
const Input = {
    p1: { targetX:300, rot:0, charge:false },
    p2: { targetX:300, rot:0, charge:false },
    
    init() {
        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ (2På¯¾å¿œ)
        window.addEventListener('keydown', e => this.keyHandler(e, true));
        window.addEventListener('keyup', e => this.keyHandler(e, false));
        
        // ã‚¿ãƒƒãƒ/ãƒã‚¦ã‚¹ç§»å‹• (P1)
        const cvs = document.getElementById('game-canvas');
        cvs.addEventListener('pointermove', (e) => {
            e.preventDefault();
            const rect = cvs.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (600 / rect.width);
            this.p1.targetX = x;
        });
        cvs.addEventListener('touchmove', e => e.preventDefault(), {passive:false});

        // ç”»é¢ä¸‹ãƒœã‚¿ãƒ³ (P1ç”¨)
        this.setupBtn('btn-left',   (on) => this.p1.rot = on ? -1 : 0);
        this.setupBtn('btn-right',  (on) => this.p1.rot = on ? 1 : 0);
        this.setupBtn('btn-charge', (on) => this.p1.charge = on);
    },

    setupBtn(id, action) {
        const el = document.getElementById(id);
        const start = (e) => {
            e.preventDefault(); el.setPointerCapture(e.pointerId);
            el.classList.add('pressed'); action(true); AudioSys.init();
        };
        const end = (e) => {
            e.preventDefault(); el.releasePointerCapture(e.pointerId);
            el.classList.remove('pressed'); action(false);
        };
        el.addEventListener('pointerdown', start);
        el.addEventListener('pointerup', end);
        el.addEventListener('pointercancel', end);
    },

    keyHandler(e, isDown) {
        const c = e.code;
        // P1: Arrows, R-Shift, Space
        if(c==='ArrowLeft') this.p1.targetX -= isDown ? 40 : 0;
        if(c==='ArrowRight') this.p1.targetX += isDown ? 40 : 0;
        if(c==='ArrowUp') this.p1.rot = isDown ? -1 : 0;   // å·¦å›è»¢
        if(c==='ArrowDown') this.p1.rot = isDown ? 1 : 0;  // å³å›è»¢
        if(c==='ShiftRight' || c==='Space') this.p1.charge = isDown;

        // P2: WASD, L-Shift
        if(c==='KeyA') this.p2.targetX -= isDown ? 40 : 0;
        if(c==='KeyD') this.p2.targetX += isDown ? 40 : 0;
        if(c==='KeyW') this.p2.rot = isDown ? -1 : 0;
        if(c==='KeyS') this.p2.rot = isDown ? 1 : 0;
        if(c==='ShiftLeft') this.p2.charge = isDown;
    }
};

// --- ãƒ‘ãƒ‰ãƒ« (ãœã‚“ã¾ã„å¼) ---
class Paddle {
    constructor(y, color, isEnemy=false) {
        this.x = 300; this.y = y; this.w = 100; this.h = 18;
        this.color = color; this.isEnemy = isEnemy;
        this.angle = 0; this.baseAngle = 0;
        this.windUp = 0; this.windDir = 1; this.spinVel = 0;
        this.isSmashing = false;
    }
    
    update(inp, dt) {
        // ç§»å‹•
        this.x += (inp.targetX - this.x) * 0.3 * dt;
        this.x = Math.max(this.w/2, Math.min(600-this.w/2, this.x));

        // å‚¾ã (éãƒãƒ£ãƒ¼ã‚¸æ™‚)
        if(!inp.charge) {
            if(inp.rot !== 0) {
                this.baseAngle += inp.rot * 0.08 * dt;
                this.baseAngle = Math.max(-0.8, Math.min(0.8, this.baseAngle));
            } else {
                this.baseAngle *= Math.pow(0.9, dt);
            }
        }

        // ãœã‚“ã¾ã„ãƒãƒ£ãƒ¼ã‚¸
        if(inp.charge) {
            // å·»ãä¸Šã’æ–¹å‘æ±ºå®š
            if(this.windUp === 0) this.windDir = (inp.rot !== 0) ? inp.rot : 1;
            
            this.windUp = Math.min(100, this.windUp + 3 * dt);
            this.angle = this.baseAngle + (this.windDir * (this.windUp/100) * Math.PI); 
            
            if(Math.floor(this.windUp) % 15 < 3 * dt) AudioSys.play('wind');
        } else {
            // è§£æ”¾
            if(this.windUp > 0) {
                this.spinVel = -(this.windDir * (this.windUp/100) * 2.0); // é€†å›è»¢
                this.windUp = 0;
                this.isSmashing = true;
                AudioSys.play('smash');
                setTimeout(() => this.isSmashing=false, 400);
            }
            this.angle += this.spinVel * dt;
            this.spinVel *= Math.pow(0.85, dt);
            this.angle += (this.baseAngle - this.angle) * 0.2 * dt;
        }
    }
    
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        if(this.isSmashing || this.windUp > 80) {
            ctx.shadowBlur = 20; ctx.shadowColor = this.color;
        }
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
        ctx.fillStyle = "#fff";
        ctx.fillRect(-this.w/2, -2, this.w, 4);
        ctx.restore();
    }
}

// --- ã‚²ãƒ¼ãƒ ã‚³ã‚¢ ---
const Game = {
    canvas: null, ctx: null, loopId: null, lastTime: 0,
    width: 600, height: 800,
    mode: 'local', role: 'p1', state: 'stop',
    p1: null, p2: null, ball: null, blocks: [],
    
    initLocal() { this.mode='local'; this.role='p1'; this.start(); },
    initOnline(isHost) { this.mode='online'; this.role=isHost?'p1':'p2'; this.start(); },
    
    start() {
        AudioSys.init(); Input.init();
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById('screen-game').classList.add('active');
        document.getElementById('modal-result').style.display='none';
        
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = 600; this.canvas.height = 800;
        
        this.p1 = new Paddle(750, '#00f2ff');
        this.p2 = new Paddle(50, '#ff0055', true);
        
        this.resetBall();
        this.blocks = [];
        for(let i=0; i<5; i++) this.blocks.push({ x:100+i*100, y:400, w:80, h:20, active:true });
        
        this.state = 'play';
        this.lastTime = performance.now();
        if(this.loopId) cancelAnimationFrame(this.loopId);
        this.loop(performance.now());
    },
    
    resetBall() {
        this.ball = { x:300, y:400, r:10, vx:0, vy:0, isSmash:false };
        const a = Math.PI/2 + (Math.random()-0.5);
        const spd = 7;
        this.ball.vx = Math.cos(a) * spd;
        this.ball.vy = Math.sin(a) * spd * (this.role==='p1'?1:-1);
        if(this.mode==='online' && this.role==='p2') { this.ball.vx=0; this.ball.vy=0; }
    },
    
    loop(timestamp) {
        if(this.state !== 'play') return;
        const dt = (timestamp - this.lastTime) / 16.66;
        this.lastTime = timestamp;
        
        this.update(dt);
        this.draw();
        
        if(this.mode==='online') this.sync();
        this.loopId = requestAnimationFrame((t) => this.loop(t));
    },
    
    update(dt) {
        // å…¥åŠ›åæ˜ : ãƒ­ãƒ¼ã‚«ãƒ«ãªã‚‰ä¸¡æ–¹ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãªã‚‰è‡ªåˆ†ã¨ç›¸æ‰‹(å—ä¿¡ãƒ‡ãƒ¼ã‚¿)
        if(this.mode === 'local') {
            this.p1.update(Input.p1, dt);
            this.p2.update(Input.p2, dt); // ãƒ­ãƒ¼ã‚«ãƒ«2Pã®æ“ä½œåæ˜ 
        } else {
            if(this.role==='p1') this.p1.update(Input.p1, dt);
            else this.p2.update(Input.p1, dt);
        }
        
        // ç‰©ç†æ¼”ç®— (Local or Host)
        if(this.mode==='local' || (this.mode==='online' && this.role==='p1')) {
            const b = this.ball;
            const spd = b.isSmash ? 1.6 : 1.0;
            b.x += b.vx * spd * dt;
            b.y += b.vy * spd * dt;
            
            if(b.x < b.r || b.x > 600-b.r) b.vx *= -1;
            
            this.checkHit(this.p1);
            this.checkHit(this.p2);
            
            this.blocks.forEach(bl => {
                if(bl.active && b.x > bl.x && b.x < bl.x+bl.w && b.y > bl.y && b.y < bl.y+bl.h) {
                    bl.active=false; AudioSys.play('break'); if(!b.isSmash) b.vy*=-1;
                }
            });
            
            if(b.y > 850) this.gameOver('p2');
            if(b.y < -50) this.gameOver('p1');
        }
    },
    
    checkHit(p) {
        const b = this.ball;
        const dx = b.x - p.x; const dy = b.y - p.y;
        const cos = Math.cos(-p.angle); const sin = Math.sin(-p.angle);
        const lx = dx * cos - dy * sin; const ly = dx * sin + dy * cos;
        
        if(lx > -p.w/2-b.r && lx < p.w/2+b.r && ly > -p.h/2-b.r && ly < p.h/2+b.r) {
            if(p.isSmashing) {
                b.isSmash = true;
                const ang = p.angle - Math.PI/2; 
                b.vx = Math.cos(ang) * 18; b.vy = Math.sin(ang) * 18;
                if(p.isEnemy) b.vy = Math.abs(b.vy); else b.vy = -Math.abs(b.vy);
                AudioSys.play('smash');
            } else {
                b.vy *= -1; b.vx += p.angle * 10;
                b.isSmash = false;
                AudioSys.play('hit');
            }
            b.y += b.vy * 2;
        }
    },
    
    draw() {
        const ctx = this.ctx; ctx.clearRect(0,0,600,800);
        this.blocks.forEach(b => {
            if(b.active) { ctx.fillStyle='#ffd700'; ctx.fillRect(b.x, b.y, b.w, b.h); }
        });
        this.p1.draw(ctx);
        this.p2.draw(ctx);
        
        ctx.fillStyle = this.ball.isSmash ? '#ffff00' : '#fff';
        if(this.ball.isSmash) { ctx.shadowBlur=20; ctx.shadowColor='#ffff00'; }
        else ctx.shadowBlur=0;
        ctx.beginPath(); ctx.arc(this.ball.x, this.ball.y, this.ball.r, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur=0;
    },
    
    sync() {
        if(this.role==='p1') {
            Net.send({ type:'sync', p1:{x:this.p1.x, a:this.p1.angle, s:this.p1.isSmashing}, b:this.ball, bl:this.blocks.map(b=>b.active)});
        } else {
            Net.send({ 
                type:'input', 
                p2:{ x:this.p2.x, a:this.p2.angle, w:this.p2.windUp, s:this.p2.isSmashing, rot:Input.p1.rot, charge:Input.p1.charge } 
            });
        }
    },
    
    onData(d) {
        if(d.type==='sync') {
            this.p2.x = d.p1.x; this.p2.angle = d.p1.a; this.p2.isSmashing = d.p1.s;
            this.ball = d.b;
            if(d.bl) d.bl.forEach((act,i) => { if(this.blocks[i]) this.blocks[i].active=act; });
        } else if(d.type==='input') {
            this.p2.x = d.p2.x; this.p2.angle = d.p2.a; 
            this.p2.windUp = d.p2.w; this.p2.isSmashing = d.p2.s;
            if(d.p2.charge && Math.floor(d.p2.w)%15===0) AudioSys.play('wind');
        } else if(d.type==='over') {
            this.gameOver(d.win ? 'WIN!' : 'LOSE...');
        }
    },
    
    gameOver(msg) {
        this.state = 'stop';
        document.getElementById('modal-result').style.display = 'flex';
        document.getElementById('res-msg').innerText = 
            (this.mode==='local') ? (msg==='p1'?"P1 WIN":"P2 WIN") : msg;
        AudioSys.play('win');
    }
};

// --- é€šä¿¡ ---
const Net = {
    peer: null, conn: null, scanner: null,
    
    openMenu() {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById('screen-net').classList.add('active');
        document.getElementById('net-select').style.display='flex';
        document.getElementById('net-host').style.display='none';
        document.getElementById('net-guest').style.display='none';
    },
    initHost() {
        Sound.init();
        document.getElementById('net-select').style.display='none';
        document.getElementById('net-host').style.display='flex';
        this.peer = new Peer();
        this.peer.on('open', id => {
            document.getElementById('host-id-text').innerText = id;
            document.getElementById('qr-display').innerHTML = "";
            new QRCode(document.getElementById("qr-display"), { text: id, width: 160, height: 160 });
        });
        this.peer.on('connection', c => { this.conn = c; this.setup(); Game.initOnline(true); });
    },
    showGuest() {
        document.getElementById('net-select').style.display='none';
        document.getElementById('net-guest').style.display='flex';
    },
    startCam() {
        Sound.init();
        const wrap = document.getElementById('cam-wrapper');
        wrap.style.display = 'block';
        this.scanner = new Html5QrcodeScanner("cam-wrapper", { fps: 10, qrbox: 200 });
        this.scanner.render((decoded) => {
            this.join(decoded); this.scanner.clear(); wrap.style.display = 'none';
        });
    },
    joinInput() { const id = document.getElementById('input-id').value; if(id) this.join(id); },
    join(id) {
        Sound.init();
        this.peer = new Peer();
        this.peer.on('open', () => { this.conn = this.peer.connect(id); this.setup(); Game.initOnline(false); });
        this.peer.on('error', () => alert("æ¥ç¶šã§ãã¾ã›ã‚“ã§ã—ãŸ"));
    },
    setup() {
        this.conn.on('data', d => Game.onData(d));
        this.conn.on('close', () => { alert("é€šä¿¡åˆ‡æ–­"); location.reload(); });
        this.conn.on('open', () => console.log("Connected"));
    },
    send(d) { if(this.conn && this.conn.open) this.conn.send(d); }
};

</script>
</body>
</html>
